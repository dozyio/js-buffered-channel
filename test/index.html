<!-- test/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BufferedChannel Test</title>
</head>
<body>
  <h1>BufferedChannel Test Page</h1>
  <button id="startTest">Start Test</button>
  <div id="log"></div>

  <script type="module">
    import { BufferedChannel } from '../dist/buffered-channel.js'

    const logDiv = document.getElementById('log')

    function log(message) {
      const p = document.createElement('p')
      p.textContent = message
      logDiv.appendChild(p)
      console.log(message) // Also log to console for Playwright to capture
    }

    document.getElementById('startTest').addEventListener('click', async () => {
      // Initialize the worker
      const worker = new Worker('worker.js', { type: 'module' })

      // Create a MessageChannel for communication
      const messageChannel = new MessageChannel()

      // Initialize BufferedChannel on the main thread's port
      const mainChannel = new BufferedChannel(messageChannel.port1, 2, 'main') // bufferSize = 2

      // Expose mainChannel to the window for Playwright tests
      window.mainChannel = mainChannel

      // Start receiving messages
      ;(async () => {
        for await (const msg of mainChannel.receive) {
          log(`Received: ${msg}`)
          if (msg.startsWith('Echo:')) {
            const receivedCount = logDiv.querySelectorAll('p').length
            if (receivedCount >= 11) { // 5 sent, 5 received, 1 termination
              log('All messages received. Terminating worker.')
              worker.terminate()
            }
          }
        }
      })()

      // Send the other port to the worker via postMessage
      worker.postMessage({ type: 'init', port: messageChannel.port2 }, [messageChannel.port2])

      // Async generator for messages
      async function* generateMessages() {
        const messagesToSend = ['Message 1', 'Message 2', 'Message 3', 'Message 4', 'Message 5']
        for (const msg of messagesToSend) {
          yield msg
          // Optionally, add a delay between messages
          await new Promise(resolve => setTimeout(resolve, 500))
        }
      }

      // Function to send messages from the async generator with controlled concurrency
      async function sendMessages(messageIterator, sendFunc, bufferSize) {
        const activePromises = new Set()

        for await (const msg of messageIterator) {
          // Start sending the message and add the promise to the active set
          const sendPromise = sendFunc(msg)
            .catch(error => {
              console.error(`Error sending ${msg}:`, error)
            })
            .finally(() => {
              // Remove the promise from the active set once it's settled
              activePromises.delete(sendPromise)
            })

          activePromises.add(sendPromise)

          // If we've reached the buffer size, wait for any promise to settle
          if (activePromises.size >= bufferSize) {
            await Promise.race(activePromises)
          }
        }

        // Await all remaining active send operations
        await Promise.all(activePromises)
      }

      // Define the send function
      const sendFunc = async (msg) => {
        await mainChannel.send(msg)
        log(`Sent: ${msg}`)
      }

      // Start sending all messages
      await sendMessages(generateMessages(), sendFunc, 2) // bufferSize = 2
      log('All messages sent.')
    })
  </script>
</body>
</html>
